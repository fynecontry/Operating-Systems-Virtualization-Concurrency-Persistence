# Summary

Segmentation solves a number of problems and helps us build a more effective virtualization of memory. Beyond just dynamic relocation, segmentation can better support sparse address spaces, by avoiding the huge potential waste of memory between logical segments of the address space. It is also fast, as doing the arithmetic segmentation is easy and well-suited to hardware; the overheads of translation are minimal. A fringe benefit arises too: code sharing. If code is placed within a separate segment, such a segment could potentially be shared across multiple running programs.

However, as we learned, allocating variable-sized segments in memory leads to some problems that we’d like to overcome. The first, as discussed above, is external fragmentation. Because segments are variable-sized, free memory gets chopped up into odd-sized pieces, and thus satisfying​ a memory-allocation request can be difficult. One can try to use smart algorithms or periodically compact memory, but the problem is fundamental and hard to avoid.

The second and perhaps more important problem is that segmentation still isn’t flexible enough to support our fully generalized, sparse address space. For example, if we have a large but sparsely-used heap all in one logical segment, the entire heap must still reside in memory in order to be accessed. In other words, if our model of how the address space is being used doesn’t exactly match how the underlying segmentation has been designed to support it, segmentation doesn’t work very well. We thus need to find some new solutions.


## Simulator
[This program](https://github.com/fynecontry/Operating-Systems-Virtualization-Concurrency-Persistence/blob/main/virtualization/segmentation/segmentation.py) allows you to see how address translations are performed in a system with segmentation. The segmentation that this system uses is pretty simple: an address space has just two segments; further, the top bit of the virtual address generated by the process determines which segment the address is in: `0 for segment 0 (where, say, code and the heap would reside) and 1 for segment 1 (where the stack lives). Segment 0 grows in a positive direction (towards higher addresses), whereas segment 1 grows in the negative direction`.

Visually, the address space looks like this:
```
 --------------- virtual address 0
 |    seg0     |
 |             |
 |             |
 |-------------|
 |             |
 |             |
 |             |
 |             |
 |(unallocated)|
 |             |
 |             |
 |             |
 |-------------|
 |             |
 |    seg1     |
 |-------------| virtual address max (size of address space)
```

With segmentation, as you might recall, there is a base/limit pair of registers per segment. Thus, in this problem, there are two base/limit pairs. The *segment-0* base tells which physical address the top of segment 0 has been placed in physical memory and the limit tells how big the segment is; the *segment-1* base tells where the bottom of segment 1 has been placed in physical memory and the corresponding limit also tells us how big the segment is (or how far it grows in the negative direction).

## Questions
#### 1 First let’s use a tiny address space to translate some addresses. Here’s a simple set of parameters with a few different random seeds; can you translate the addresses?
```
segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 0

segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 1

segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 2
```

```
# ./segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 0 -c && ./segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 1 -c && ./segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 3 -c
ARG seed 0
ARG address space size 128
ARG phys mem size 512

Segment register information:

  Segment 0 base  (grows positive) : 0x00000000 (decimal 0)
  Segment 0 limit                  : 20

  Segment 1 base  (grows negative) : 0x00000200 (decimal 512)
  Segment 1 limit                  : 20

Virtual Address Trace
  VA  0: 0x0000006c (decimal:  108) --> VALID in SEG1: 0x000001ec (decimal:  492)
  VA  1: 0x00000061 (decimal:   97) --> SEGMENTATION VIOLATION (SEG1)
  VA  2: 0x00000035 (decimal:   53) --> SEGMENTATION VIOLATION (SEG0)
  VA  3: 0x00000021 (decimal:   33) --> SEGMENTATION VIOLATION (SEG0)
  VA  4: 0x00000041 (decimal:   65) --> SEGMENTATION VIOLATION (SEG1)

ARG seed 1
ARG address space size 128
ARG phys mem size 512

Segment register information:

  Segment 0 base  (grows positive) : 0x00000000 (decimal 0)
  Segment 0 limit                  : 20

  Segment 1 base  (grows negative) : 0x00000200 (decimal 512)
  Segment 1 limit                  : 20

Virtual Address Trace
  VA  0: 0x00000011 (decimal:   17) --> VALID in SEG0: 0x00000011 (decimal:   17)
  VA  1: 0x0000006c (decimal:  108) --> VALID in SEG1: 0x000001ec (decimal:  492)
  VA  2: 0x00000061 (decimal:   97) --> SEGMENTATION VIOLATION (SEG1)
  VA  3: 0x00000020 (decimal:   32) --> SEGMENTATION VIOLATION (SEG0)
  VA  4: 0x0000003f (decimal:   63) --> SEGMENTATION VIOLATION (SEG0)

ARG seed 3
ARG address space size 128
ARG phys mem size 512

Segment register information:

  Segment 0 base  (grows positive) : 0x00000000 (decimal 0)
  Segment 0 limit                  : 20

  Segment 1 base  (grows negative) : 0x00000200 (decimal 512)
  Segment 1 limit                  : 20

Virtual Address Trace
  VA  0: 0x0000001e (decimal:   30) --> SEGMENTATION VIOLATION (SEG0)
  VA  1: 0x00000045 (decimal:   69) --> SEGMENTATION VIOLATION (SEG1)
  VA  2: 0x0000002f (decimal:   47) --> SEGMENTATION VIOLATION (SEG0)
  VA  3: 0x0000004d (decimal:   77) --> SEGMENTATION VIOLATION (SEG1)
  VA  4: 0x00000050 (decimal:   80) --> SEGMENTATION VIOLATION (SEG1)
```

#### 2. Now, let’s see if we understand this tiny address space we’ve constructed (using the parameters from the question above). What is the highest legal virtual address in segment 0? What about the lowest legal virtual address in segment 1? What are the lowest and highest illegal addresses in this entire address space? Finally, how would you run `segmentation.py` with the `-A` flag to test if you are right? 
`# ./segmentation.py -a 128 -p 512 -b 0 -l 20 -B 512 -L 20 -s 0 -A 17,108,30,97 -c`

**highest legal virtual address in segment 0**
> VA  0: 0x00000011 (decimal:   17) --> VALID in SEG0: 0x00000011 (decimal:   17)


**lowest legal virtual address in segment 1**
> VA  1: 0x0000006c (decimal:  108) --> VALID in SEG1: 0x000001ec (decimal:  492)

**lowest and highest illegal addresses in this entire address space, respectively**
> VA  0: 0x0000001e (decimal:   30) --> SEGMENTATION VIOLATION (SEG0)

> VA  1: 0x00000061 (decimal:   97) --> SEGMENTATION VIOLATION (SEG1)


#### 3. Let’s say we have a tiny 16-byte address space in a 128-byte physical memory. What base and bounds would you set up so as to get the simulator to generate the following translation results for the specified address stream: valid, valid, violation, …, violation, valid, valid? Assume the following parameters: `segmentation.py -a 16 -p 128 -A 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 --b0? --l0? --b1? --l2?`
```
# ./segmentation.py -a 16 -p 128 -A 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15 --b0 53 --l0 2 --b1 40 --l1 2 -c
ARG seed 0
ARG address space size 16
ARG phys mem size 128

Segment register information:

  Segment 0 base  (grows positive) : 0x00000035 (decimal 53)
  Segment 0 limit                  : 2

  Segment 1 base  (grows negative) : 0x00000028 (decimal 40)
  Segment 1 limit                  : 2

Virtual Address Trace
  VA  0: 0x00000000 (decimal:    0) --> VALID in SEG0: 0x00000035 (decimal:   53)
  VA  1: 0x00000001 (decimal:    1) --> VALID in SEG0: 0x00000036 (decimal:   54)
  VA  2: 0x00000002 (decimal:    2) --> SEGMENTATION VIOLATION (SEG0)
  VA  3: 0x00000003 (decimal:    3) --> SEGMENTATION VIOLATION (SEG0)
  VA  4: 0x00000004 (decimal:    4) --> SEGMENTATION VIOLATION (SEG0)
  VA  5: 0x00000005 (decimal:    5) --> SEGMENTATION VIOLATION (SEG0)
  VA  6: 0x00000006 (decimal:    6) --> SEGMENTATION VIOLATION (SEG0)
  VA  7: 0x00000007 (decimal:    7) --> SEGMENTATION VIOLATION (SEG0)
  VA  8: 0x00000008 (decimal:    8) --> SEGMENTATION VIOLATION (SEG1)
  VA  9: 0x00000009 (decimal:    9) --> SEGMENTATION VIOLATION (SEG1)
  VA 10: 0x0000000a (decimal:   10) --> SEGMENTATION VIOLATION (SEG1)
  VA 11: 0x0000000b (decimal:   11) --> SEGMENTATION VIOLATION (SEG1)
  VA 12: 0x0000000c (decimal:   12) --> SEGMENTATION VIOLATION (SEG1)
  VA 13: 0x0000000d (decimal:   13) --> SEGMENTATION VIOLATION (SEG1)
  VA 14: 0x0000000e (decimal:   14) --> VALID in SEG1: 0x00000026 (decimal:   38)
  VA 15: 0x0000000f (decimal:   15) --> VALID in SEG1: 0x00000027 (decimal:   39)
```

#### 4. Assume we want to generate a problem where roughly 90% of the randomly-generated virtual addresses are valid (not segmentation violations). How should you configure the simulator to do so? Which parameters are important to getting this outcome?
```
# ./segmentation.py -a 16 -p 128 -A 0,1,2,3,4,5,6,7,8,9,10 -b 53 -l 8 -c
ARG seed 0
ARG address space size 16
ARG phys mem size 128

Segment register information:

  Segment 0 base  (grows positive) : 0x00000035 (decimal 53)
  Segment 0 limit                  : 8

  Segment 1 base  (grows negative) : 0x00000068 (decimal 104)
  Segment 1 limit                  : 7

Virtual Address Trace
  VA  0: 0x00000000 (decimal:    0) --> VALID in SEG0: 0x00000035 (decimal:   53)
  VA  1: 0x00000001 (decimal:    1) --> VALID in SEG0: 0x00000036 (decimal:   54)
  VA  2: 0x00000002 (decimal:    2) --> VALID in SEG0: 0x00000037 (decimal:   55)
  VA  3: 0x00000003 (decimal:    3) --> VALID in SEG0: 0x00000038 (decimal:   56)
  VA  4: 0x00000004 (decimal:    4) --> VALID in SEG0: 0x00000039 (decimal:   57)
  VA  5: 0x00000005 (decimal:    5) --> VALID in SEG0: 0x0000003a (decimal:   58)
  VA  6: 0x00000006 (decimal:    6) --> VALID in SEG0: 0x0000003b (decimal:   59)
  VA  7: 0x00000007 (decimal:    7) --> VALID in SEG0: 0x0000003c (decimal:   60)
  VA  8: 0x00000008 (decimal:    8) --> SEGMENTATION VIOLATION (SEG1)
  VA  9: 0x00000009 (decimal:    9) --> VALID in SEG1: 0x00000061 (decimal:   97)
  VA 10: 0x0000000a (decimal:   10) --> VALID in SEG1: 0x00000062 (decimal:   98)
```

#### 5. Can you run the simulator such that no virtual addresses are valid? How?
```
# ./segmentation.py -c -l 0 -L 0
ARG seed 0
ARG address space size 1k
ARG phys mem size 16k

Segment register information:

  Segment 0 base  (grows positive) : 0x0000360b (decimal 13835)
  Segment 0 limit                  : 0

  Segment 1 base  (grows negative) : 0x00003082 (decimal 12418)
  Segment 1 limit                  : 0

Virtual Address Trace
  VA  0: 0x000001ae (decimal:  430) --> SEGMENTATION VIOLATION (SEG0)
  VA  1: 0x00000109 (decimal:  265) --> SEGMENTATION VIOLATION (SEG0)
  VA  2: 0x0000020b (decimal:  523) --> SEGMENTATION VIOLATION (SEG1)
  VA  3: 0x0000019e (decimal:  414) --> SEGMENTATION VIOLATION (SEG0)
  VA  4: 0x00000322 (decimal:  802) --> SEGMENTATION VIOLATION (SEG1)
```